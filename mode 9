import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import re

# === Load CSV ===
csv_path = "OAP_analysis_overview.csv"
df = pd.read_csv(csv_path)

param_col = "AVERAGE POWER PER ORBIT [W]"

# Files to include (your list)
files_plot = [
    "orbit_500_ltan_10_output_plus10_SUN_GS_output.txt",
    "orbit_500_ltan_10_output_plus10_SUN_NADIR_output.txt",
    "orbit_500_ltan_10_output_plus10_SUN_VELOCITY_output.txt",
    "orbit_500_ltan_10_output_plus10_VELOCITY_GS_output.txt",
    "orbit_500_ltan_10_output_plus10_VELOCITY_NADIR_output.txt",
    "orbit_500_ltan_10_output_plus10_VELOCITY_SUN_output.txt",
]

sub = df[df["File"].isin(files_plot)].copy()
if sub.empty:
    raise RuntimeError("None of the specified files were found in the CSV. Check filenames/paths.")

# ---- Parse filename -> Altitude, LTAN, Cant, Mode ----
# 'middle' can be "plus10_SUN_GS" or "fault_1_VELOCITY_NADIR" or just "SUN_GS"
pat = re.compile(r"orbit_(\d+)_ltan_(\d+)_output_(.+?)_output\.txt")
mode_tail = re.compile(r"(SUN_(?:GS|NADIR|VELOCITY)|VELOCITY_(?:GS|NADIR|SUN))$")

def parse_parts(fname):
    m = pat.match(fname)
    if not m:
        return None, None, None, None
    alt, ltan, middle = m.groups()
    mm = mode_tail.search(middle)
    if mm:
        mode = mm.group(1)
        cant = middle[: mm.start()].strip("_")  # prefix before the mode
        cant = cant or None
    else:
        # Fallback: treat whole middle as mode if no match (rare)
        mode, cant = middle, None
    return int(alt), int(ltan), cant, mode

sub[["Altitude","LTAN","Cant","Mode"]] = sub["File"].apply(lambda f: pd.Series(parse_parts(f)))

# ---- Orders (auto-detect, but keep preferred mode order when present) ----
preferred_mode_order = ["SUN_GS","SUN_NADIR","SUN_VELOCITY","VELOCITY_GS","VELOCITY_NADIR","VELOCITY_SUN"]
mode_order = [m for m in preferred_mode_order if m in set(sub["Mode"])]
if not mode_order:
    mode_order = sorted(sub["Mode"].unique())

ltan_order = sorted(sub["LTAN"].unique())         # likely [10]
alt_order  = sorted(sub["Altitude"].unique())     # likely [500]

# ---- Colours by MODE (pastel) + short labels ----
mode_colors = {
    "SUN_GS":          "#aec7e8",
    "SUN_NADIR":       "#ffbb78",
    "SUN_VELOCITY":    "#98df8a",
    "VELOCITY_GS":     "#ff9896",
    "VELOCITY_NADIR":  "#c5b0d5",
    "VELOCITY_SUN":    "#c49c94",
}
mode_short = {
    "SUN_GS":"SGS", "SUN_NADIR":"SND", "SUN_VELOCITY":"SV",
    "VELOCITY_GS":"VGS", "VELOCITY_NADIR":"VNA", "VELOCITY_SUN":"VS"
}
alt_hatch = {alt: ("//" if alt == 600 else "") for alt in alt_order}

# ---- Geometry ----
bar_w   = 0.10
pair_gap = 0.015
mode_gap = 0.08
group_gap = 0.25

# ---- Build bars & ticks ----
bars = []                # (x, y, color, hatch)
group_centers = []
minor_centers = []
minor_labels  = []

x_cursor = 0.0
for lt in ltan_order:
    group_start = x_cursor
    for mode in mode_order:
        # bars for each altitude actually present
        for i, alt in enumerate(alt_order):
            x = x_cursor + i * (bar_w + pair_gap)
            match = sub[(sub["LTAN"] == lt) & (sub["Mode"] == mode) & (sub["Altitude"] == alt)]
            if not match.empty and pd.notna(match.iloc[0][param_col]):
                y = float(match.iloc[0][param_col])
                bars.append((x, y, mode_colors.get(mode, "#cccccc"), alt_hatch[alt]))
        # minor tick per mode subgroup
        width_used = len(alt_order) * (bar_w + pair_gap) - pair_gap if alt_order else 0
        mode_center = x_cursor + max(width_used, bar_w) / 2.0
        minor_centers.append(mode_center)
        minor_labels.append(mode_short.get(mode, mode))
        x_cursor += len(alt_order) * (bar_w + pair_gap) + mode_gap
    span = len(mode_order)*(len(alt_order)*(bar_w+pair_gap)+mode_gap) - mode_gap
    group_centers.append(group_start + span/2.0)
    x_cursor += group_gap

# ---- Plot ----
fig, ax = plt.subplots(figsize=(12, 5))

for x, h, color, hatch in bars:
    ax.bar(x, h, width=bar_w, color=color, edgecolor="black", linewidth=0.5, hatch=hatch)

# Major LTAN ticks (spaced from minor)
ax.set_xticks(group_centers)
ax.set_xticklabels([f"LTAN {lt}" for lt in ltan_order])
ax.tick_params(axis="x", which="major", pad=26, labelsize=11)

# Minor mode ticks
ax.set_xticks(minor_centers, minor=True)
ax.set_xticklabels(minor_labels, minor=True)
ax.tick_params(axis="x", which="minor", pad=6, labelsize=9, length=0)

ax.set_xlabel("LTAN (grouped). Within each group, mode-coloured bars" + (", 500/600 pairs" if len(alt_order)>1 else ""))
ax.set_ylabel(param_col)
ax.set_title("Average Power per Orbit â€” LTAN grouped, mode-coloured (plus10 case)")
ax.grid(axis="y", linestyle="--", alpha=0.7)

# Legend (mode colours). Altitude legend only if multiple altitudes.
mode_handles = [plt.Rectangle((0,0),1,1, facecolor=mode_colors[m], edgecolor="black", linewidth=0.5)
                for m in mode_order]
first_legend = ax.legend(mode_handles, mode_order, title="Operational Mode",
                         loc="upper left", bbox_to_anchor=(1.01, 1))
ax.add_artist(first_legend)

if len(alt_order) > 1:
    alt_handles = [plt.Rectangle((0,0),1,1, facecolor="#dddddd", edgecolor="black", linewidth=0.5,
                                 hatch=("//" if a==600 else "")) for a in alt_order]
    ax.legend(alt_handles, [f"{a} km" for a in alt_order], title="Altitude",
              loc="lower left", bbox_to_anchor=(1.01, 0))

plt.subplots_adjust(right=0.8, bottom=0.22)

# Save
out_path = "ltan10_plus10_modes.png"
plt.savefig(out_path, dpi=300)
plt.close()

print(f"Saved {out_path}")
